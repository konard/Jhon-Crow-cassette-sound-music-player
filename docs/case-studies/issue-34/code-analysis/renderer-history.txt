cf8b822 Update playlist when track changes
diff --git a/src/renderer.js b/src/renderer.js
index 4670efb..82a81f0 100644
--- a/src/renderer.js
+++ b/src/renderer.js
@@ -976,6 +976,11 @@ async function loadTrack(index) {
   // Update status bar
   updateStatusBar(`${index + 1}/${audioState.audioFiles.length}: ${track.name}`);
 
+  // Update playlist if it's open
+  if (playlistOpen) {
+    updatePlaylistTracks();
+  }
+
   // Load audio - use appropriate source based on platform
   try {
     if (track._isNativePath && track.url) {
65cbe06 Add playlist panel with shuffle functionality
diff --git a/src/renderer.js b/src/renderer.js
index 5cbab49..4670efb 100644
--- a/src/renderer.js
+++ b/src/renderer.js
@@ -77,6 +77,9 @@ const CONFIG = {
   },
   ui: {
     showControlsHint: true  // Default: show controls hint
+  },
+  playback: {
+    shuffleEnabled: false  // Default: shuffle disabled
   }
 };
 
@@ -176,6 +179,10 @@ async function loadSavedSettings() {
         if (settings.ui) {
           CONFIG.ui.showControlsHint = settings.ui.showControlsHint ?? CONFIG.ui.showControlsHint;
         }
+        // Apply playback settings
+        if (settings.playback) {
+          CONFIG.playback.shuffleEnabled = settings.playback.shuffleEnabled ?? CONFIG.playback.shuffleEnabled;
+        }
         // Restore playback state (folder and track)
         if (settings.playback && settings.playback.folderPath) {
           await restorePlaybackState(settings.playback);
@@ -242,7 +249,8 @@ function saveCurrentSettings() {
         },
         playback: {
           folderPath: audioState.folderPath,
-          currentTrackIndex: audioState.currentTrackIndex
+          currentTrackIndex: audioState.currentTrackIndex,
+          shuffleEnabled: CONFIG.playback.shuffleEnabled
         }
       };
       window.electronAPI.saveSettings(settings);
@@ -1098,7 +1106,19 @@ function pause() {
 }
 
 async function nextTrack() {
-  await loadTrack(audioState.currentTrackIndex + 1);
+  let nextIndex;
+
+  if (CONFIG.playback.shuffleEnabled && audioState.audioFiles.length > 1) {
+    // Shuffle: pick random track (different from current)
+    do {
+      nextIndex = Math.floor(Math.random() * audioState.audioFiles.length);
+    } while (nextIndex === audioState.currentTrackIndex && audioState.audioFiles.length > 1);
+  } else {
+    // Sequential: next track in order
+    nextIndex = audioState.currentTrackIndex + 1;
+  }
+
+  await loadTrack(nextIndex);
   if (audioState.isPlaying) {
     await audioState.audioElement.play();
   }
@@ -1662,6 +1682,14 @@ function setupEventListeners() {
   // Right-click to open settings panel (desktop)
   canvas.addEventListener('contextmenu', onContextMenu);
 
+  // Middle-click to open playlist panel
+  canvas.addEventListener('auxclick', (e) => {
+    if (e.button === 1) {  // Middle mouse button
+      e.preventDefault();
+      togglePlaylist();
+    }
+  });
+
   // Double-click to open folder (desktop)
   canvas.addEventListener('dblclick', async () => {
     await openFolder();
@@ -1703,6 +1731,9 @@ function setupEventListeners() {
   // Setup settings panel event listeners
   setupSettingsEventListeners();
 
+  // Setup playlist panel event listeners
+  setupPlaylistEventListeners();
+
   // Listen for tray toggle play event (Electron only)
   if (isElectron && window.electronAPI.onTrayTogglePlay) {
     window.electronAPI.onTrayTogglePlay(async () => {
@@ -2128,6 +2159,92 @@ function toggleSettings() {
   }
 }
 
+// ============================================================================
+// PLAYLIST PANEL FUNCTIONS
+// ============================================================================
+let playlistOpen = false;
+
+function openPlaylist() {
+  const overlay = document.getElementById('playlist-overlay');
+  overlay.classList.add('visible');
+  playlistOpen = true;
+  updatePlaylistTracks();
+}
+
+function closePlaylist() {
+  const overlay = document.getElementById('playlist-overlay');
+  overlay.classList.remove('visible');
+  playlistOpen = false;
+}
+
+function togglePlaylist() {
+  if (playlistOpen) {
+    closePlaylist();
+  } else {
+    openPlaylist();
+  }
+}
+
+function updatePlaylistTracks() {
+  const container = document.getElementById('playlist-tracks');
+
+  if (audioState.audioFiles.length === 0) {
+    container.innerHTML = '<div class="playlist-empty">No tracks loaded</div>';
+    return;
+  }
+
+  container.innerHTML = '';
+
+  audioState.audioFiles.forEach((track, index) => {
+    const trackElement = document.createElement('div');
+    trackElement.className = 'playlist-track';
+    if (index === audioState.currentTrackIndex) {
+      trackElement.classList.add('active');
+    }
+
+    const trackNumber = document.createElement('div');
+    trackNumber.className = 'playlist-track-number';
+    trackNumber.textContent = (index + 1).toString();
+
+    const trackName = document.createElement('div');
+    trackName.className = 'playlist-track-name';
+    trackName.textContent = track.name;
+
+    trackElement.appendChild(trackNumber);
+    trackElement.appendChild(trackName);
+
+    trackElement.addEventListener('click', async () => {
+      await loadTrack(index);
+      if (audioState.isPlaying) {
+        await audioState.audioElement.play();
+      }
+      updatePlaylistTracks();
+    });
+
+    container.appendChild(trackElement);
+  });
+}
+
+function setupPlaylistEventListeners() {
+  // Close button
+  document.getElementById('playlist-close').addEventListener('click', closePlaylist);
+
+  // Close on overlay click (but not on panel itself)
+  document.getElementById('playlist-overlay').addEventListener('click', (e) => {
+    if (e.target.id === 'playlist-overlay') {
+      closePlaylist();
+    }
+  });
+
+  // Shuffle toggle
+  const shuffleCheckbox = document.getElementById('checkbox-shuffle');
+  shuffleCheckbox.checked = CONFIG.playback.shuffleEnabled;
+  shuffleCheckbox.addEventListener('change', (e) => {
+    CONFIG.playback.shuffleEnabled = e.target.checked;
+    saveCurrentSettings();
+  });
+}
+
 function syncSettingsUI() {
   // Sync slider values with current CONFIG
   document.getElementById('slider-volume').value = CONFIG.audio.volume * 100;
8a62ec7 Add option to hide controls hint in settings
diff --git a/src/renderer.js b/src/renderer.js
index b4c5196..5cbab49 100644
--- a/src/renderer.js
+++ b/src/renderer.js
@@ -74,6 +74,9 @@ const CONFIG = {
   },
   mobile: {
     autoRotate: false  // Default: locked to landscape
+  },
+  ui: {
+    showControlsHint: true  // Default: show controls hint
   }
 };
 
@@ -130,6 +133,9 @@ async function init() {
   // Apply loaded appearance settings
   updateBackgroundGradient();
 
+  // Apply loaded UI settings
+  updateControlsHintVisibility();
+
   // Set initial visibility for bottom captions based on window size
   updateBottomCaptionsVisibility();
 
@@ -166,6 +172,10 @@ async function loadSavedSettings() {
           CONFIG.appearance.gradientAngle = settings.appearance.gradientAngle ?? CONFIG.appearance.gradientAngle;
           CONFIG.appearance.backgroundOpacity = settings.appearance.backgroundOpacity ?? CONFIG.appearance.backgroundOpacity;
         }
+        // Apply UI settings
+        if (settings.ui) {
+          CONFIG.ui.showControlsHint = settings.ui.showControlsHint ?? CONFIG.ui.showControlsHint;
+        }
         // Restore playback state (folder and track)
         if (settings.playback && settings.playback.folderPath) {
           await restorePlaybackState(settings.playback);
@@ -227,6 +237,9 @@ function saveCurrentSettings() {
           gradientAngle: CONFIG.appearance.gradientAngle,
           backgroundOpacity: CONFIG.appearance.backgroundOpacity
         },
+        ui: {
+          showControlsHint: CONFIG.ui.showControlsHint
+        },
         playback: {
           folderPath: audioState.folderPath,
           currentTrackIndex: audioState.currentTrackIndex
@@ -319,7 +332,12 @@ function updateBottomCaptionsVisibility() {
   const isSmallHeight = window.innerHeight < captionThreshold;
 
   if (controlsHint) {
-    controlsHint.style.display = isSmallHeight ? 'none' : 'block';
+    // Respect user preference for controls hint visibility
+    if (!CONFIG.ui.showControlsHint) {
+      controlsHint.style.display = 'none';
+    } else {
+      controlsHint.style.display = isSmallHeight ? 'none' : 'block';
+    }
   }
   if (statusBar) {
     statusBar.style.display = isSmallHeight ? 'none' : 'block';
@@ -1600,6 +1618,18 @@ function hexToRgba(hex, alpha) {
   return `rgba(${r}, ${g}, ${b}, ${alpha})`;
 }
 
+// Update controls hint visibility based on current UI settings
+function updateControlsHintVisibility() {
+  const controlsHint = document.getElementById('controls-hint');
+  if (!controlsHint) return;
+
+  if (CONFIG.ui.showControlsHint) {
+    controlsHint.style.display = 'block';
+  } else {
+    controlsHint.style.display = 'none';
+  }
+}
+
 // ============================================================================
 // EVENT HANDLERS
 // ============================================================================
@@ -2141,6 +2171,9 @@ function syncSettingsUI() {
   if (isMobile || isCapacitor) {
     document.getElementById('checkbox-auto-rotate').checked = CONFIG.mobile.autoRotate;
   }
+
+  // Sync UI settings (controls hint visibility)
+  document.getElementById('checkbox-show-controls-hint').checked = CONFIG.ui.showControlsHint;
 }
 
 function setupSettingsEventListeners() {
@@ -2295,6 +2328,13 @@ function setupSettingsEventListeners() {
     await applyOrientationSetting();
   });
 
+  // Show controls hint checkbox
+  document.getElementById('checkbox-show-controls-hint').addEventListener('change', (e) => {
+    CONFIG.ui.showControlsHint = e.target.checked;
+    updateControlsHintVisibility();
+    saveCurrentSettings();
+  });
+
   // Appearance settings - Gradient enabled checkbox
   document.getElementById('checkbox-gradient-enabled').addEventListener('change', (e) => {
     CONFIG.appearance.gradientEnabled = e.target.checked;
07acdd3 Improve button hit detection with larger invisible collision boxes
diff --git a/src/renderer.js b/src/renderer.js
index f5b1144..b4c5196 100644
--- a/src/renderer.js
+++ b/src/renderer.js
@@ -578,6 +578,19 @@ function createCassettePlayer() {
     button.userData.buttonType = btn.type;
     button.userData.isButton = true;
     buttonsGroup.add(button);
+
+    // Add larger invisible collision box for easier clicking/tapping
+    // Makes the clickable area extend above and below the visual button
+    const collisionBoxGeometry = new THREE.BoxGeometry(0.014, 0.012, 0.012);
+    const collisionBox = new THREE.Mesh(
+      collisionBoxGeometry,
+      new THREE.MeshBasicMaterial({ visible: false, transparent: true, opacity: 0 })
+    );
+    collisionBox.position.set(btn.x, buttonY + 0.002, buttonZ);
+    collisionBox.name = btn.name + 'Collision';
+    collisionBox.userData.buttonType = btn.type;
+    collisionBox.userData.isButton = true;
+    buttonsGroup.add(collisionBox);
   });
 
   // Play button has red dot
@@ -591,6 +604,18 @@ function createCassettePlayer() {
   playDot.userData.isButton = true;
   buttonsGroup.add(playDot);
 
+  // Add larger invisible collision box for the play dot too
+  const playDotCollisionGeometry = new THREE.BoxGeometry(0.014, 0.012, 0.012);
+  const playDotCollision = new THREE.Mesh(
+    playDotCollisionGeometry,
+    new THREE.MeshBasicMaterial({ visible: false, transparent: true, opacity: 0 })
+  );
+  playDotCollision.position.set(-buttonSpacing * 0.5, buttonY + 0.005, buttonZ);
+  playDotCollision.name = 'playDotCollision';
+  playDotCollision.userData.buttonType = 'play';
+  playDotCollision.userData.isButton = true;
+  buttonsGroup.add(playDotCollision);
+
   group.add(buttonsGroup);
   group.userData.buttonsGroup = buttonsGroup;
 
3ed0c5a Fix Android audio playback with native file picker and convertFileSrc
diff --git a/src/renderer.js b/src/renderer.js
index fd0949d..f5b1144 100644
--- a/src/renderer.js
+++ b/src/renderer.js
@@ -15,6 +15,9 @@ let ScreenOrientation = null;
 // Filesystem API for permission management (Capacitor)
 let Filesystem = null;
 
+// File Picker API for native file selection (Capacitor - resolves Android blob URL issues)
+let FilePicker = null;
+
 // Apply mobile class to body if on mobile platform
 if (isMobile || isCapacitor) {
   document.addEventListener('DOMContentLoaded', () => {
@@ -25,6 +28,7 @@ if (isMobile || isCapacitor) {
   if (isCapacitor && window.Capacitor.Plugins) {
     ScreenOrientation = window.Capacitor.Plugins.ScreenOrientation;
     Filesystem = window.Capacitor.Plugins.Filesystem;
+    FilePicker = window.Capacitor.Plugins.FilePicker;
   }
 }
 
@@ -923,15 +927,26 @@ async function loadTrack(index) {
 
   // Load audio - use appropriate source based on platform
   try {
-    if (track.url) {
-      // Web/Mobile: use blob URL
+    if (track._isNativePath && track.url) {
+      // Native path (from Capacitor FilePicker): URL already converted via convertFileSrc
+      // This is the most reliable method for Android - avoids blob URL issues
+      console.log(`[Mobile] Loading with native path: ${track.name}, URL: ${track.url}`);
+      audioState.audioElement.src = track.url;
+    } else if (track.url) {
+      // Web/Mobile: use blob URL (fallback when native picker not available)
       if (isMobile || isCapacitor) {
-        console.log(`[Mobile] Loading track: ${track.name}, URL type: ${track.url.substring(0, 20)}..., retryCount: ${track._retryCount}`);
+        console.log(`[Mobile] Loading with blob URL: ${track.name}, URL: ${track.url.substring(0, 50)}..., retryCount: ${track._retryCount}`);
       }
       audioState.audioElement.src = track.url;
-    } else if (track.path) {
+    } else if (track.path && isElectron) {
       // Electron: use file:// URL
       audioState.audioElement.src = 'file://' + track.path;
+    } else if (track.path && isCapacitor && window.Capacitor && window.Capacitor.convertFileSrc) {
+      // Capacitor with native path but URL not yet converted
+      console.log(`[Mobile] Converting native path: ${track.path}`);
+      track.url = window.Capacitor.convertFileSrc(track.path);
+      track._isNativePath = true;
+      audioState.audioElement.src = track.url;
     } else if (track.file) {
       // Fallback: create blob URL from File object if URL is missing
       // Use createObjectURL directly on File (don't wrap in new Blob)
@@ -943,15 +958,19 @@ async function loadTrack(index) {
     await audioState.audioElement.load();
 
     if (isMobile || isCapacitor) {
-      console.log(`[Mobile] Track loaded successfully: ${track.name}`);
+      console.log(`[Mobile] Track loaded successfully: ${track.name}, isNativePath: ${track._isNativePath}`);
     }
   } catch (error) {
     console.error(`Error loading track ${track.name}:`, error);
     updateStatusBar(`Error: ${error.message}`);
 
-    // On mobile, try fallback methods
-    if ((isMobile || isCapacitor) && track.file) {
+    // On mobile, try fallback methods (only if not using native path - native paths don't have File objects)
+    if ((isMobile || isCapacitor) && track.file && !track._isNativePath) {
       await tryFallbackLoading(track);
+    } else if (track._isNativePath) {
+      // Native path failed - this shouldn't happen normally
+      console.error(`[Mobile] Native path loading failed for: ${track.name}`);
+      updateStatusBar(`Cannot play: ${track.name}`);
     }
   }
 
@@ -1349,7 +1368,20 @@ async function requestStoragePermissions() {
 
 // Web/Mobile file picker using file input element
 async function openFilesWeb() {
-  // On Capacitor/Android, request storage permissions first
+  // On Capacitor/Android, prefer native FilePicker to get proper file paths
+  // This avoids blob URL issues that cause MEDIA_ERR_SRC_NOT_SUPPORTED
+  if (isCapacitor && FilePicker) {
+    try {
+      console.log('[Mobile] Using native FilePicker plugin');
+      await openFilesNative();
+      return;
+    } catch (error) {
+      console.error('[Mobile] Native FilePicker failed, falling back to HTML input:', error);
+      // Fall through to HTML input method
+    }
+  }
+
+  // On Capacitor/Android, request storage permissions first (for HTML input fallback)
   if (isCapacitor) {
     const permissionGranted = await requestStoragePermissions();
     if (!permissionGranted) {
@@ -1418,11 +1450,79 @@ async function openFilesWeb() {
   });
 }
 
+// Native file picker using @capawesome/capacitor-file-picker
+// This returns native file paths which can be converted to web-accessible URLs
+// Avoids blob URL issues that cause MEDIA_ERR_SRC_NOT_SUPPORTED on Android WebView
+async function openFilesNative() {
+  console.log('[Mobile] Opening native file picker...');
+  updateStatusBar('Opening file picker...');
+
+  try {
+    // Request permissions first
+    await requestStoragePermissions();
+
+    // Pick audio files using native file picker
+    const result = await FilePicker.pickFiles({
+      types: ['audio/*'],
+      multiple: true,
+      readData: false  // Don't read file content into memory - we just need paths
+    });
+
+    console.log('[Mobile] FilePicker result:', result);
+
+    if (result && result.files && result.files.length > 0) {
+      // Clean up old URLs
+      cleanupBlobUrls();
+
+      const audioFiles = result.files.map((file) => {
+        // Convert native path to web-accessible URL using Capacitor.convertFileSrc()
+        // This is the key fix - avoids blob URLs which don't work on Android WebView
+        let url = null;
+        if (file.path && window.Capacitor && window.Capacitor.convertFileSrc) {
+          url = window.Capacitor.convertFileSrc(file.path);
+          console.log(`[Mobile] Converted path: ${file.path} -> ${url}`);
+        }
+
+        const actualType = file.mimeType || getMimeType(file.name);
+
+        console.log(`[Mobile] Native file: ${file.name}, path: ${file.path}, mimeType: ${actualType}, webUrl: ${url}`);
+
+        return {
+          name: file.name.replace(/\.[^/.]+$/, ''),
+          fullName: file.name,
+          path: file.path,      // Native file path (Android/iOS)
+          url: url,             // Web-accessible URL via convertFileSrc
+          mimeType: actualType,
+          size: file.size,
+          _retryCount: 0,
+          _isNativePath: true   // Flag to indicate this uses native path, not blob URL
+        };
+      });
+
+      audioState.folderPath = null;
+      audioState.audioFiles = audioFiles;
+      audioState.currentTrackIndex = 0;
+
+      await loadTrack(0);
+      updateStatusBar(`Loaded ${audioFiles.length} tracks`);
+    } else {
+      console.log('[Mobile] No files selected');
+      updateStatusBar('No files selected');
